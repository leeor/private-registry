// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Char = require("bs-platform/lib/js/char.js");
var Block = require("bs-platform/lib/js/block.js");
var $$String = require("bs-platform/lib/js/string.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

var Result = {
  getExn: Belt_Result.getExn,
  mapWithDefaultU: Belt_Result.mapWithDefaultU,
  mapWithDefault: Belt_Result.mapWithDefault,
  mapU: Belt_Result.mapU,
  map: Belt_Result.map,
  flatMapU: Belt_Result.flatMapU,
  flatMap: Belt_Result.flatMap,
  getWithDefault: Belt_Result.getWithDefault,
  isOk: Belt_Result.isOk,
  isError: Belt_Result.isError,
  eqU: Belt_Result.eqU,
  eq: Belt_Result.eq,
  cmpU: Belt_Result.cmpU,
  cmp: Belt_Result.cmp,
  let_: Belt_Result.flatMap
};

function syntaxError(a) {
  return /* Error */Block.__(1, [/* SyntaxError */[a]]);
}

function tokenKind(param) {
  if (typeof param === "number") {
    switch (param) {
      case /* StartOfFile */0 :
          return "<SOF>";
      case /* EndOfFile */1 :
          return "<EOF>";
      case /* Bang */2 :
          return "!";
      case /* Dollar */3 :
      case /* Amp */4 :
          return "$";
      case /* ParenOpen */5 :
          return "(";
      case /* ParenClose */6 :
          return ")";
      case /* Spread */7 :
          return "...";
      case /* Colon */8 :
          return ":";
      case /* Equals */9 :
          return "=";
      case /* At */10 :
          return "@";
      case /* BracketOpen */11 :
          return "[";
      case /* BracketClose */12 :
          return "]";
      case /* BraceOpen */13 :
          return "{";
      case /* BraceClose */14 :
          return "}";
      case /* Pipe */15 :
          return "|";
      
    }
  } else {
    switch (param.tag | 0) {
      case /* Name */0 :
          return "Name";
      case /* Int */1 :
          return "Int";
      case /* Float */2 :
          return "Float";
      case /* String */3 :
          return "String";
      case /* Comment */4 :
          return "Comment";
      
    }
  }
}

function tokenDesc(param) {
  var $$location = param.location;
  var token = param.token;
  var tmp;
  if (typeof token === "number") {
    tmp = " kind: '" + (tokenKind(token) + "'");
  } else {
    switch (token.tag | 0) {
      case /* Name */0 :
      case /* Int */1 :
      case /* Float */2 :
      case /* String */3 :
      case /* Comment */4 :
          tmp = " kind: '" + (tokenKind(token) + ("', value: " + token[0]));
          break;
      
    }
  }
  return "(" + (String($$location.line) + (":" + (String($$location.column) + (")" + tmp))));
}

function isChar(source, position, $$char) {
  if (position < source.length) {
    return Caml_string.get(source, position) === $$char;
  } else {
    return false;
  }
}

function positionAfterWhitespace(lexer, startPosition) {
  var source = lexer.source;
  var _position = startPosition;
  while(true) {
    var position = _position;
    if (position >= source.length) {
      return position;
    } else {
      var bom = Caml_string.get(source, position);
      if (bom === 65279) {
        return position + 1 | 0;
      } else {
        var switcher = bom - 32 | 0;
        if (switcher > 12 || switcher < 0) {
          switch (switcher) {
            case -23 :
                _position = position + 1 | 0;
                continue ;
            case -22 :
                var newPosition = position + 1 | 0;
                lexer.line = lexer.line + 1 | 0;
                lexer.lineStart = newPosition;
                _position = newPosition;
                continue ;
            case -21 :
            case -20 :
                return position;
            case -19 :
                var match = isChar(source, position + 1 | 0, /* "\n" */10);
                var newPosition$1 = match ? position + 2 | 0 : position + 1 | 0;
                lexer.line = lexer.line + 1 | 0;
                lexer.lineStart = newPosition$1;
                _position = newPosition$1;
                continue ;
            default:
              return position;
          }
        } else if (switcher > 11 || switcher < 1) {
          _position = position + 1 | 0;
          continue ;
        } else {
          return position;
        }
      }
    }
  };
}

function isNameChar(param) {
  if (param >= 91) {
    if (param >= 97) {
      return param < 123;
    } else {
      return param === 95;
    }
  } else if (param >= 58) {
    return param >= 65;
  } else {
    return param >= 48;
  }
}

function readName(source, start, line, column) {
  var _position = start;
  while(true) {
    var position = _position;
    var match = Caml_string.get(source, position);
    if (match >= 91) {
      if (match >= 97) {
        if (match < 123) {
          _position = position + 1 | 0;
          continue ;
        }
        
      } else if (match === 95) {
        _position = position + 1 | 0;
        continue ;
      }
      
    } else if (match >= 58) {
      if (match >= 65) {
        _position = position + 1 | 0;
        continue ;
      }
      
    } else if (match >= 48) {
      _position = position + 1 | 0;
      continue ;
    }
    return {
            token: /* Name */Block.__(0, [$$String.sub(source, start, position - start | 0)]),
            location: {
              start: start,
              end_: position,
              line: line,
              column: column
            }
          };
  };
}

function readComment(source, start, line, column) {
  var aux = function (_position) {
    while(true) {
      var position = _position;
      if (position > source.length) {
        return position;
      } else {
        var match = Caml_string.get(source, position);
        if (match !== 10 && match !== 13) {
          _position = position + 1 | 0;
          continue ;
        } else {
          return position;
        }
      }
    };
  };
  var position = aux(start);
  return {
          token: /* Comment */Block.__(4, [$$String.sub(source, start, position - start | 0)]),
          location: {
            start: start,
            end_: position,
            line: line,
            column: column
          }
        };
}

function readDigits(source, startingPosition) {
  var source$1 = source;
  var _pos = startingPosition;
  while(true) {
    var pos = _pos;
    if (pos >= source$1.length) {
      return /* Ok */Block.__(0, [pos]);
    } else {
      var c = Caml_string.get(source$1, pos);
      if (c > 57 || c < 48) {
        if (pos === startingPosition) {
          var a = "Invalid number, expected digit but got: " + $$String.make(1, c);
          return /* Error */Block.__(1, [/* SyntaxError */[a]]);
        } else {
          return /* Ok */Block.__(0, [pos]);
        }
      } else {
        _pos = pos + 1 | 0;
        continue ;
      }
    }
  };
}

function readNumber(source, start, line, column) {
  var isFloat = {
    contents: false
  };
  var position = {
    contents: start
  };
  if (Caml_string.get(source, start) === /* "-" */45) {
    position.contents = position.contents + 1 | 0;
  }
  var tmp;
  if (Caml_string.get(source, position.contents) === /* "0" */48) {
    position.contents = position.contents + 1 | 0;
    var $$char = Caml_string.get(source, position.contents);
    if ($$char > 57 || $$char < 48) {
      tmp = /* Ok */Block.__(0, [/* () */0]);
    } else {
      var a = "Invalid number, unexpected digit after 0: " + $$String.make(1, $$char);
      tmp = /* Error */Block.__(1, [/* SyntaxError */[a]]);
    }
  } else {
    tmp = Belt_Result.flatMap(readDigits(source, position.contents), (function (pos) {
            return /* Ok */Block.__(0, [(position.contents = pos, /* () */0)]);
          }));
  }
  return Belt_Result.flatMap(tmp, (function (param) {
                return Belt_Result.flatMap(isChar(source, position.contents, /* "." */46) ? (isFloat.contents = true, position.contents = position.contents + 1 | 0, Belt_Result.flatMap(readDigits(source, position.contents), (function (pos) {
                                      return /* Ok */Block.__(0, [(position.contents = pos, /* () */0)]);
                                    }))) : /* Ok */Block.__(0, [/* () */0]), (function (param) {
                              var tmp;
                              if (isChar(source, position.contents, /* "E" */69) || isChar(source, position.contents, /* "e" */101)) {
                                isFloat.contents = true;
                                position.contents = position.contents + 1 | 0;
                                if (isChar(source, position.contents, /* "+" */43) || isChar(source, position.contents, /* "-" */45)) {
                                  position.contents = position.contents + 1 | 0;
                                }
                                tmp = Belt_Result.flatMap(readDigits(source, position.contents), (function (pos) {
                                        return /* Ok */Block.__(0, [(position.contents = pos, /* () */0)]);
                                      }));
                              } else {
                                tmp = /* Ok */Block.__(0, [/* () */0]);
                              }
                              return Belt_Result.flatMap(tmp, (function (param) {
                                            var loc_end_ = position.contents;
                                            var loc = {
                                              start: start,
                                              end_: loc_end_,
                                              line: line,
                                              column: column
                                            };
                                            var match = isFloat.contents;
                                            var tok = match ? /* Float */Block.__(2, [$$String.sub(source, start, position.contents - start | 0)]) : /* Int */Block.__(1, [$$String.sub(source, start, position.contents - start | 0)]);
                                            return /* Ok */Block.__(0, [{
                                                        token: tok,
                                                        location: loc
                                                      }]);
                                          }));
                            }));
              }));
}

function char2hex(c) {
  var match = c >= 48 && c <= 57;
  if (match) {
    return c - 48 | 0;
  } else {
    var match$1 = c >= 65 && c <= 70;
    if (match$1) {
      return c - 55 | 0;
    } else {
      var match$2 = c >= 97 && c <= 102;
      if (match$2) {
        return c - 87 | 0;
      } else {
        return -1;
      }
    }
  }
}

function uniCharCode(a, b, c, d) {
  return (char2hex(a) << 12) | (char2hex(b) << 8) | (char2hex(c) << 4) | char2hex(d);
}

function readString(source, start, line, column) {
  var aux = function (value, position, chunkStart) {
    return Belt_Result.flatMap(position >= source.length ? /* Error */Block.__(1, [/* SyntaxError */["Unterminated string"]]) : /* Ok */Block.__(0, [/* () */0]), (function (param) {
                  var c = Caml_string.get(source, position);
                  if (c !== 10) {
                    if (c !== 34) {
                      if (c === 92) {
                        var newPosition = {
                          contents: position + 1 | 0
                        };
                        var code = Caml_string.get(source, newPosition.contents);
                        var tmp;
                        var exit = 0;
                        if (code !== 34) {
                          if (code >= 92) {
                            if (code >= 118) {
                              exit = 1;
                            } else {
                              switch (code - 92 | 0) {
                                case 0 :
                                    tmp = /* Ok */Block.__(0, ["\\"]);
                                    break;
                                case 6 :
                                    tmp = /* Ok */Block.__(0, ["\b"]);
                                    break;
                                case 10 :
                                    tmp = /* Ok */Block.__(0, ["\\f"]);
                                    break;
                                case 18 :
                                    tmp = /* Ok */Block.__(0, ["\n"]);
                                    break;
                                case 22 :
                                    tmp = /* Ok */Block.__(0, ["\r"]);
                                    break;
                                case 1 :
                                case 2 :
                                case 3 :
                                case 4 :
                                case 5 :
                                case 7 :
                                case 8 :
                                case 9 :
                                case 11 :
                                case 12 :
                                case 13 :
                                case 14 :
                                case 15 :
                                case 16 :
                                case 17 :
                                case 19 :
                                case 20 :
                                case 21 :
                                case 23 :
                                    exit = 1;
                                    break;
                                case 24 :
                                    tmp = /* Ok */Block.__(0, ["\t"]);
                                    break;
                                case 25 :
                                    var charCode = uniCharCode(Caml_string.get(source, position + 1 | 0), Caml_string.get(source, position + 2 | 0), Caml_string.get(source, position + 3 | 0), Caml_string.get(source, position + 4 | 0));
                                    if (charCode < 0) {
                                      var a = "Invalid character escape sequence: \\u" + ($$String.sub(source, position + 1 | 0, position + 5 | 0) + ".");
                                      tmp = /* Error */Block.__(1, [/* SyntaxError */[a]]);
                                    } else {
                                      newPosition.contents = newPosition.contents + 4 | 0;
                                      tmp = /* Ok */Block.__(0, [$$String.make(1, Char.chr(charCode))]);
                                    }
                                    break;
                                
                              }
                            }
                          } else if (code !== 47) {
                            exit = 1;
                          } else {
                            tmp = /* Ok */Block.__(0, ["/"]);
                          }
                        } else {
                          tmp = /* Ok */Block.__(0, ["\""]);
                        }
                        if (exit === 1) {
                          var a$1 = "Invalid character escape sequence: \\" + $$String.make(1, Char.chr(code));
                          tmp = /* Error */Block.__(1, [/* SyntaxError */[a$1]]);
                        }
                        return Belt_Result.flatMap(tmp, (function (rest) {
                                      var value$1 = value + ($$String.sub(source, chunkStart, (newPosition.contents - chunkStart | 0) - 1 | 0) + rest);
                                      var nextPosition = newPosition.contents + 1 | 0;
                                      return aux(value$1, nextPosition, nextPosition);
                                    }));
                      } else {
                        return aux(value, position + 1 | 0, chunkStart);
                      }
                    } else {
                      return /* Ok */Block.__(0, [{
                                  token: /* String */Block.__(3, [value + $$String.sub(source, chunkStart, position - chunkStart | 0)]),
                                  location: {
                                    start: start,
                                    end_: position + 1 | 0,
                                    line: line,
                                    column: column
                                  }
                                }]);
                    }
                  } else {
                    return /* Error */Block.__(1, [/* SyntaxError */["Unterminated string"]]);
                  }
                }));
  };
  return aux("", start + 1 | 0, start + 1 | 0);
}

function readToken(lexer, from) {
  var source = lexer.source;
  var position = positionAfterWhitespace(lexer, from);
  var line = lexer.line;
  var column = (1 + position | 0) - lexer.lineStart | 0;
  var sourceLength = source.length;
  var singleWidth_end_ = position + 1 | 0;
  var singleWidth = {
    start: position,
    end_: singleWidth_end_,
    line: line,
    column: column
  };
  if (position >= source.length) {
    return /* Ok */Block.__(0, [{
                token: /* EndOfFile */1,
                location: {
                  start: sourceLength,
                  end_: sourceLength,
                  line: line,
                  column: column
                }
              }]);
  } else {
    var $$char = Caml_string.get(source, position);
    var exit = 0;
    var switcher = $$char - 33 | 0;
    if (switcher > 89 || switcher < 0) {
      switch (switcher) {
        case 90 :
            return /* Ok */Block.__(0, [{
                        token: /* BraceOpen */13,
                        location: singleWidth
                      }]);
        case 91 :
            return /* Ok */Block.__(0, [{
                        token: /* Pipe */15,
                        location: singleWidth
                      }]);
        case 92 :
            return /* Ok */Block.__(0, [{
                        token: /* BraceClose */14,
                        location: singleWidth
                      }]);
        default:
          exit = 1;
      }
    } else if (switcher >= 64) {
      exit = 2;
    } else {
      switch (switcher) {
        case 0 :
            return /* Ok */Block.__(0, [{
                        token: /* Bang */2,
                        location: singleWidth
                      }]);
        case 1 :
            return readString(source, position, line, column);
        case 2 :
            return /* Ok */Block.__(0, [readComment(source, position, line, column)]);
        case 3 :
            return /* Ok */Block.__(0, [{
                        token: /* Dollar */3,
                        location: singleWidth
                      }]);
        case 5 :
            return /* Ok */Block.__(0, [{
                        token: /* Amp */4,
                        location: singleWidth
                      }]);
        case 7 :
            return /* Ok */Block.__(0, [{
                        token: /* ParenOpen */5,
                        location: singleWidth
                      }]);
        case 8 :
            return /* Ok */Block.__(0, [{
                        token: /* ParenClose */6,
                        location: singleWidth
                      }]);
        case 13 :
            if (isChar(source, position + 1 | 0, /* "." */46) && isChar(source, position + 2 | 0, /* "." */46)) {
              return /* Ok */Block.__(0, [{
                          token: /* Spread */7,
                          location: {
                            start: position,
                            end_: position + 3 | 0,
                            line: line,
                            column: column
                          }
                        }]);
            } else if ((position + 1 | 0) >= source.length) {
              return /* Error */Block.__(1, [/* SyntaxError */["Unexpected End of File"]]);
            } else {
              var a = "Unexpected Character" + $$String.make(1, Caml_string.get(source, position + 1 | 0));
              return /* Error */Block.__(1, [/* SyntaxError */[a]]);
            }
        case 12 :
        case 15 :
        case 16 :
        case 17 :
        case 18 :
        case 19 :
        case 20 :
        case 21 :
        case 22 :
        case 23 :
        case 24 :
            exit = 3;
            break;
        case 25 :
            return /* Ok */Block.__(0, [{
                        token: /* Colon */8,
                        location: singleWidth
                      }]);
        case 28 :
            return /* Ok */Block.__(0, [{
                        token: /* Equals */9,
                        location: singleWidth
                      }]);
        case 31 :
            return /* Ok */Block.__(0, [{
                        token: /* At */10,
                        location: singleWidth
                      }]);
        case 58 :
            return /* Ok */Block.__(0, [{
                        token: /* BracketOpen */11,
                        location: singleWidth
                      }]);
        case 60 :
            return /* Ok */Block.__(0, [{
                        token: /* BracketClose */12,
                        location: singleWidth
                      }]);
        case 32 :
        case 33 :
        case 34 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 40 :
        case 41 :
        case 42 :
        case 43 :
        case 44 :
        case 45 :
        case 46 :
        case 47 :
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
        case 62 :
            exit = 2;
            break;
        case 4 :
        case 6 :
        case 9 :
        case 10 :
        case 11 :
        case 14 :
        case 26 :
        case 27 :
        case 29 :
        case 30 :
        case 59 :
        case 61 :
        case 63 :
            exit = 1;
            break;
        
      }
    }
    switch (exit) {
      case 1 :
          var a$1 = "Unexpected Character" + $$String.make(1, $$char);
          return /* Error */Block.__(1, [/* SyntaxError */[a$1]]);
      case 2 :
          return /* Ok */Block.__(0, [readName(source, position, line, column)]);
      case 3 :
          return readNumber(source, position, line, column);
      
    }
  }
}

function make(source) {
  return {
          source: source,
          curr: {
            token: /* StartOfFile */0,
            location: {
              start: 0,
              end_: 0,
              line: 1,
              column: 0
            }
          },
          line: 1,
          lineStart: 0
        };
}

function lookahead(lexer) {
  var tokenResult = lexer.curr;
  var match = tokenResult.token;
  if (typeof match === "number" && match === 1) {
    return /* Ok */Block.__(0, [tokenResult]);
  }
  var skipComment = function (prevToken) {
    return Belt_Result.flatMap(readToken(lexer, prevToken.location.end_), (function (token) {
                  var tmp = token.token;
                  if (typeof tmp === "number" || tmp.tag !== /* Comment */4) {
                    return /* Ok */Block.__(0, [token]);
                  } else {
                    return skipComment(token);
                  }
                }));
  };
  return skipComment(lexer.curr);
}

function advance(lexer) {
  return Belt_Result.flatMap(lookahead(lexer), (function (curr) {
                lexer.curr = curr;
                return /* Ok */Block.__(0, [curr]);
              }));
}

exports.Result = Result;
exports.syntaxError = syntaxError;
exports.tokenKind = tokenKind;
exports.tokenDesc = tokenDesc;
exports.isChar = isChar;
exports.positionAfterWhitespace = positionAfterWhitespace;
exports.isNameChar = isNameChar;
exports.readName = readName;
exports.readComment = readComment;
exports.readDigits = readDigits;
exports.readNumber = readNumber;
exports.char2hex = char2hex;
exports.uniCharCode = uniCharCode;
exports.readString = readString;
exports.readToken = readToken;
exports.make = make;
exports.lookahead = lookahead;
exports.advance = advance;
/* No side effect */
